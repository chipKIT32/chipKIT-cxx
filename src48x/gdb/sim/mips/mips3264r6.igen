:function:::void:do_rint:int fd, int fs, int fmt, instruction_word instruction_0
{
  unsigned64 result = 0;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  TRACE_ALU_INPUT1 (FGR[fs]);
  RoundToIntegralExact (ValueFPR (fs, fmt), &result, fmt);
  StoreFPR (fd, fmt, result);
  TRACE_ALU_RESULT (FGR[fd]);
}

:function:::void:do_class:int fd, int fs, int fmt, instruction_word instruction_0
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (fd, fmt, Classify (ValueFPR (fs, fmt), fmt));
}

:function:::void:do_min:int fd, int fs, int ft, int fmt, instruction_word instruction_0
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  TRACE_ALU_INPUT2 (FGR[fs], FGR[ft]);
  StoreFPR (fd, fmt, Min (ValueFPR (fs, fmt), ValueFPR (ft, fmt), fmt));
  TRACE_ALU_RESULT (FGR[fd]);
}

:function:::void:do_max:int fd, int fs, int ft, int fmt, instruction_word instruction_0
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  TRACE_ALU_INPUT2 (FGR[fs], FGR[ft]);
  StoreFPR (fd, fmt, Max (ValueFPR (fs, fmt), ValueFPR (ft, fmt), fmt));
  TRACE_ALU_RESULT (FGR[fd]);
}

:function:::void:do_mina:int fd, int fs, int ft, int fmt, instruction_word instruction_0
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  TRACE_ALU_INPUT2 (FGR[fs], FGR[ft]);
  StoreFPR (fd, fmt, MinA (ValueFPR (fs, fmt), ValueFPR (ft, fmt), fmt));
  TRACE_ALU_RESULT (FGR[fd]);
}

:function:::void:do_maxa:int fd, int fs, int ft, int fmt, instruction_word instruction_0
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  TRACE_ALU_INPUT2 (FGR[fs], FGR[ft]);
  StoreFPR (fd, fmt, MaxA (ValueFPR (fs, fmt), ValueFPR (ft, fmt), fmt));
  TRACE_ALU_RESULT (FGR[fd]);
}

:function:::void:do_maddf:int fd, int fs, int ft, int fmt, instruction_word instruction_0
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  TRACE_ALU_INPUT3 (FGR[fd], FGR[fs], FGR[ft]);
  StoreFPR (fd, fmt, FusedMultiplyAdd (ValueFPR (fs, fmt),
				       ValueFPR (ft, fmt),
				       ValueFPR (fd, fmt), fmt));
  TRACE_ALU_RESULT (FGR[fd]);
}

:function:::void:do_msubf:int fd, int fs, int ft, int fmt, instruction_word instruction_0
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  TRACE_ALU_INPUT3 (FGR[fd], FGR[fs], FGR[ft]);
  StoreFPR (fd, fmt, FusedMultiplySub (ValueFPR (fs, fmt),
				       ValueFPR (ft, fmt),
				       ValueFPR (fd, fmt), fmt));
  TRACE_ALU_RESULT (FGR[fd]);
}

:function:::void:do_cmp:int fd, int fs, int ft, int fmt, int condition
{
  unsigned64 result;
  check_fpu (SD_);
  TRACE_ALU_INPUT2 (ValueFPR (fs, fmt), ValueFPR (ft, fmt));
  result = R6Compare (ValueFPR (fs, fmt), ValueFPR (ft, fmt), fmt, condition);
  StoreFPR (fd, fmt, result);
  TRACE_ALU_RESULT (result);
}

:function:::void:do_self:int fd, int fs, int ft, int fmt, instruction_word instruction_0
{
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  TRACE_ALU_INPUT3 (FGR[fd], ValueFPR(fs, fmt), ValueFPR(ft, fmt));
  if ((FGR[fd] & 0x01) != 0)
    StoreFPR (fd, fmt, ValueFPR (ft, fmt));
  else
    StoreFPR (fd, fmt, ValueFPR (fs, fmt));
  TRACE_ALU_RESULT (ValueFPR(fd, fmt));
}

:function:::void:do_seleqzf:int fd, int fs, int ft, int fmt, instruction_word instruction_0
{
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  TRACE_ALU_INPUT2 (ValueFPR(fs, fmt), FGR[ft]);
  if ((FGR[ft] & 0x01) == 0)
    StoreFPR (fd, fmt, ValueFPR (fs, fmt));
  else
    StoreFPR (fd, fmt, 0);
  TRACE_ALU_RESULT (ValueFPR(fd, fmt));
}

:function:::void:do_selnezf:int fd, int fs, int ft, int fmt, instruction_word instruction_0
{
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  TRACE_ALU_INPUT2 (ValueFPR(fs, fmt), FGR[ft]);
  if ((FGR[ft] & 0x01) == 0x1)
    StoreFPR (fd, fmt, ValueFPR (fs, fmt));
  else
    StoreFPR (fd, fmt, 0);
  TRACE_ALU_RESULT (ValueFPR(fd, fmt));
}

:function:::void:do_seleqz:int rd, int rs, int rt
{
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  if (GPR[rt] != 0)
    GPR[rd] = 0;
  else
    GPR[rd] = GPR[rs];
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_selnez:int rd, int rs, int rt
{
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  if (GPR[rt] != 0)
    GPR[rd] = GPR[rs];
  else
    GPR[rd] = 0;
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_muh:int rd, int rs, int rt
{
  signed64 prod;
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = ((signed64)(signed32) GPR[rs])
    * ((signed64)(signed32) GPR[rt]);
  GPR[rd] = EXTEND32 (VH4_8 (prod));
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_mulu:int rd, int rs, int rt
{
  unsigned64 prod;
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = ((unsigned64)(unsigned32) GPR[rs])
    * ((unsigned64)(unsigned32) GPR[rt]);
  GPR[rd] = EXTEND32 (VL4_8 (prod));
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_muhu:int rd, int rs, int rt
{
  unsigned64 prod;
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = ((unsigned64)(unsigned32) GPR[rs])
    * ((unsigned64)(unsigned32) GPR[rt]);
  GPR[rd] = EXTEND32 (VH4_8 (prod));
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_div:int rd, int rs, int rt
*mips32r6:
*micromips32r6:
*mips64r6:
*micromips64r6:
{
  signed32 n = GPR[rs];
  signed32 d = GPR[rt];
  TRACE_ALU_INPUT2 (n,d);
  if (d == 0)
    GPR[rd] = EXTEND32 (0x80000000);
  else if (n == SIGNED32 (0x80000000) && d == -1)
    GPR[rd] = EXTEND32 (0x80000000);
  else
    GPR[rd] = EXTEND32 (n / d);

  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_mod:int rd, int rs, int rt
{
  signed32 n = GPR[rs];
  signed32 d = GPR[rt];
  TRACE_ALU_INPUT2 (n,d);
  if (d == 0 || (n == SIGNED32 (0x80000000) && d == -1))
    GPR[rd] = EXTEND32 (0);
  else
    GPR[rd] = EXTEND32 (n % d);

  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_divu:int rd, int rs, int rt
*mips32r6:
*micromips32r6:
*mips64r6:
*micromips64r6:
{
  unsigned32 n = GPR[rs];
  unsigned32 d = GPR[rt];
  TRACE_ALU_INPUT2 (n,d);
  if (d == 0)
    GPR[rd] = EXTEND32 (0x80000000);
  else
    GPR[rd] = EXTEND32 (n / d);

  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_modu:int rd, int rs, int rt
{
  unsigned32 n = GPR[rs];
  unsigned32 d = GPR[rt];
  TRACE_ALU_INPUT2 (n,d);
  if (d == 0)
    GPR[rd] = EXTEND32 (0);
  else
    GPR[rd] = EXTEND32 (n % d);

  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_dmul:int rd, int rs, int rt, instruction_word instruction_0
{
  unsigned64 lo;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 mid;
  int sign;
  unsigned64 op1 = GPR[rs];
  unsigned64 op2 = GPR[rt];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (op1, op2);
  /* make signed multiply unsigned */
  sign = 0;
  if ((signed64) op1 < 0)
    {
      op1 = - op1;
      ++sign;
    }
  if ((signed64) op2 < 0)
    {
      op2 = - op2;
      ++sign;
    }
  /* multiply out the sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
	 + (unsigned64) VL4_8 (m10)
	 + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);
  /* fix the sign */
  if (sign & 1)
    lo = -lo;

  GPR[rd] = lo;
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_dmuh:int rd, int rs, int rt, instruction_word instruction_0
{
  unsigned64 lo;
  unsigned64 hi;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 m11;
  unsigned64 mid;
  int sign;
  unsigned64 op1 = GPR[rs];
  unsigned64 op2 = GPR[rt];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (op1, op2);
  /* make signed multiply unsigned */
  sign = 0;
  if ((signed64) op1 < 0)
    {
      op1 = - op1;
      ++sign;
    }
  if ((signed64) op2 < 0)
    {
      op2 = - op2;
      ++sign;
    }
  /* multiply out the 4 sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  m11 = ((unsigned64) VH4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
	 + (unsigned64) VL4_8 (m10)
	 + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);
  hi = (m11
	+ (unsigned64) VH4_8 (mid)
	+ (unsigned64) VH4_8 (m01)
	+ (unsigned64) VH4_8 (m10));
  /* fix the sign */
  if (sign & 1)
    {
      lo = -lo;
      if (lo == 0)
	hi = -hi;
      else
	hi = -hi - 1;
    }

  GPR[rd] = hi;
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_dmulu:int rd, int rs, int rt, instruction_word instruction_0
{
  unsigned64 lo;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 mid;
  unsigned64 op1 = GPR[rs];
  unsigned64 op2 = GPR[rt];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (op1, op2);
  /* multiply out the sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
	 + (unsigned64) VL4_8 (m10)
	 + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);

  GPR[rd] = lo;
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_dmuhu:int rd, int rs, int rt, instruction_word instruction_0
{
  unsigned64 lo;
  unsigned64 hi;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 m11;
  unsigned64 mid;
  unsigned64 op1 = GPR[rs];
  unsigned64 op2 = GPR[rt];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (op1, op2);
  /* multiply out the 4 sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  m11 = ((unsigned64) VH4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
	 + (unsigned64) VL4_8 (m10)
	 + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);
  hi = (m11
	+ (unsigned64) VH4_8 (mid)
	+ (unsigned64) VH4_8 (m01)
	+ (unsigned64) VH4_8 (m10));

  GPR[rd] = hi;
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_ddiv:int rd, int rs, int rt, instruction_word instruction_0
*mips64r6:
*micromips64r6:
{
  signed64 n = GPR[rs];
  signed64 d = GPR[rt];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (n, d);
  if (d == 0)
    GPR[rd] = SIGNED64 (0x8000000000000000);
  else if (d == -1 && n == SIGNED64 (0x8000000000000000))
    GPR[rd] = SIGNED64 (0x8000000000000000);
  else
    GPR[rd] = (n / d);

  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_dmod:int rd, int rs, int rt, instruction_word instruction_0
{
  signed64 n = GPR[rs];
  signed64 d = GPR[rt];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (n, d);
  if (d == 0 || (d == -1 && n == SIGNED64 (0x8000000000000000)))
    GPR[rd] = SIGNED64 (0);
  else
    GPR[rd] = (n % d);

  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_ddivu:int rd, int rs, int rt, instruction_word instruction_0
*mips64r6:
*micromips64r6:
{
  unsigned64 n = GPR[rs];
  unsigned64 d = GPR[rt];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (n, d);
  if (d == 0)
    GPR[rd] = UNSIGNED64 (0x8000000000000000);
  else
    GPR[rd] = (n / d);

  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_dmodu:int rd, int rs, int rt, instruction_word instruction_0
{
  unsigned64 n = GPR[rs];
  unsigned64 d = GPR[rt];

  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (n, d);
  if (d == 0)
    GPR[rd] = UNSIGNED64 (0);
  else
    GPR[rd] = (n % d);

  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::address_word:do_bxxxc:int rt, int rs, address_word offset, address_word nia
*mips32r6:
*mips64r6:
*micromips32r6:
*micromips64r6:
{
  if (rs >= rt)
    {
      //BOVC
      ALU32_BEGIN (GPR[rs] & 0x0ffffffff);
      ALU32_ADD (GPR[rt] & 0x0ffffffff);

      if (ALU32_HAD_OVERFLOW)
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  else if (rs == 0)
    {
      RA = nia | isa_mode;
      //BEQZALC
      if (GPR[rt] == 0)
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  else
    {
      //BEQC
      if (GPR[rs] == GPR[rt])
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  return NIA;
}

:function:::address_word:do_bnxxxc:int rt, int rs, address_word offset, address_word nia
*mips32r6:
*mips64r6:
*micromips32r6:
*micromips64r6:
{
  if (rs >= rt)
    {
      //BNVC
      ALU32_BEGIN (GPR[rs] & 0x0ffffffff);
      ALU32_ADD (GPR[rt] & 0x0ffffffff);

      if (!ALU32_HAD_OVERFLOW)
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  else if (rs == 0 && rt > rs)
    {
      //BNEZALC
      RA = nia | isa_mode;
      if (GPR[rt] != 0)
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  else
    {
      //BNEC
      if (GPR[rt] != GPR[rs])
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  return NIA;
}

:function:::address_word:do_b1xxc:int rt, int rs, address_word offset, address_word nia
*mips32r6:
*mips64r6:
*micromips32r6:
*micromips64r6:
{
  if (rs == 0 && rt != 0)
    {
      //BLEZC
      if ((signed_word)GPR[rt] <= 0)
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  else if (rs != 0 && rs == rt)
    {
      //BGEZC
      if ((signed_word)GPR[rt] >= 0)
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  else
    {
      //BGEC
      if ((signed_word) GPR[rs] >= (signed_word) GPR[rt])
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  return NIA;
}

:function:::address_word:do_b2xxc:int rt, int rs, address_word offset, address_word nia
*mips32r6:
*mips64r6:
*micromips32r6:
*micromips64r6:
{
  if (rs == 0 && rt != 0)
    {
      //BGTZC
      if ((signed_word)GPR[rt] > 0)
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  else if (rs != 0 && rs == rt)
    {
      //BLTZC
      if ((signed_word)GPR[rt] < 0)
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  else
    {
      //BLTC
      if ((signed_word) GPR[rs] < (signed_word) GPR[rt])
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  return NIA;
}

:function:::address_word:do_b3xxc:int rt, int rs, address_word offset, address_word nia
*mips32r6:
*mips64r6:
*micromips32r6:
*micromips64r6:
{
  if (rs == 0 && rt != 0)
    {
      //BLEZALC
      RA = nia | isa_mode;
      if ((signed_word)GPR[rt] <= 0)
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  else if (rs != 0 && rs == rt)
    {
      //BGEZALC
      RA = nia | isa_mode;
      if ((signed_word)GPR[rt] >= 0)
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  else
    {
      //BGEUC
      if (GPR[rs] >= GPR[rt])
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  return NIA;
}

:function:::address_word:do_b4xxc:int rt, int rs, address_word offset, address_word nia
*mips32r6:
*mips64r6:
*micromips32r6:
*micromips64r6:
{
  if (rs == 0 && rt != 0)
    {
      //BGTZALC
      RA = nia | isa_mode;
      if ((signed_word)GPR[rt] > 0)
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  else if (rs != 0 && rs == rt)
    {
      //BLTZALC
      RA = nia | isa_mode;
      if ((signed_word)GPR[rt] < 0)
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  else
    {
      //BLTUC
      if (GPR[rs] < GPR[rt])
	return nia + offset;
      else
	FORBIDDEN_SLOT ();
    }
  return NIA;
}

:function:::address_word:do_bc:address_word offset
{
  return CIA + offset + 4;
}

:function:::address_word:do_balc:address_word offset
{
  RA = (CIA + 4) | isa_mode;
  return CIA + offset + 4;
}

:function:::address_word:do_beqzc:int rs, address_word offset, address_word nia
*mips32r6:
*mips64r6:
*micromips32r6:
*micromips64r6:
{
  if (GPR[rs] == 0)
    return nia + offset;
  else
    FORBIDDEN_SLOT ();
  return NIA;
}

:function:::address_word:do_bnezc:int rs, address_word offset, address_word nia
*mips32r6:
*mips64r6:
*micromips32r6:
*micromips64r6:
{
  if (GPR[rs] != 0)
    return nia + offset;
  else
    FORBIDDEN_SLOT ();
  return NIA;
}

:function:::address_word:do_jic:int rt, unsigned16 offset
*mips32r6:
*mips64r6:
*micromips32r6:
*micromips64r6:
{
  return process_isa_mode (SD_, GPR[rt] + EXTEND16(offset));
}

:function:::address_word:do_jialc:int rt, unsigned16 offset
*mips32r6:
*mips64r6:
*micromips32r6:
*micromips64r6:
{
  RA = (CIA + 4) | isa_mode;
  return process_isa_mode (SD_, GPR[rt] + EXTEND16(offset));
}

:function:::void:do_align:int rd, int rs, int rt, unsigned immediate
{
  unsigned32 grs = GPR[rs];
  unsigned32 grt = GPR[rt];
  TRACE_ALU_INPUT2 (grs, grt);
  GPR[rd] = EXTEND32 (grs >> 8 * (4 - immediate) | grt << 8 * immediate);
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_dalign:int rd, int rs, int rt, unsigned immediate
{
  unsigned64 grs = GPR[rs];
  unsigned64 grt = GPR[rt];
  TRACE_ALU_INPUT2 (grs, grt);
  GPR[rd] = grs >> 8 * (8 - immediate) | grt << 8 * immediate;
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_bitswap:int rd, int rt
{
  /* Taken from: http://graphics.stanford.edu/~seander/bithacks.html */
  unsigned32 v = GPR[rt];

  TRACE_ALU_INPUT1 (v);
  v = ((v >> 1)  & 0x55555555) | ((v & 0x55555555) << 1);
  v = ((v >> 2)  & 0x33333333) | ((v & 0x33333333) << 2);
  v = ((v >> 4)  & 0x0F0F0F0F) | ((v & 0x0F0F0F0F) << 4);
  GPR[rd] = EXTEND32 (v);
  TRACE_ALU_RESULT(GPR[rd]);
}

:function:::void:do_dbitswap:int rd, int rt
{
  /* Taken from: http://graphics.stanford.edu/~seander/bithacks.html */
  unsigned64 v = GPR[rt];

  TRACE_ALU_INPUT1 (v);
  v = ((v >> 1)  & 0x5555555555555555) | ((v & 0x5555555555555555) << 1);
  v = ((v >> 2)  & 0x3333333333333333) | ((v & 0x3333333333333333) << 2);
  v = ((v >> 4)  & 0x0F0F0F0F0F0F0F0F) | ((v & 0x0F0F0F0F0F0F0F0F) << 4);
  TRACE_ALU_RESULT(v);
  GPR[rd] = v;
}

:function:::void:do_lsa:int rd, int rs, int rt, unsigned immediate
{
  unsigned32 t = GPR[rs] << (immediate + 1);
  GPR[rd] = EXTEND32(GPR[rt] + t);
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_dlsa:int rd, int rs, int rt, unsigned immediate
{
  unsigned64 t = GPR[rs] << (immediate + 1);
  GPR[rd] = GPR[rt] + t;
  TRACE_ALU_RESULT (GPR[rd]);
}

:function:::void:do_aui:int rt, int rs, unsigned16 immediate
{
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = EXTEND32 (GPR[rs] + (EXTEND16 (immediate) << 16));
  TRACE_ALU_RESULT (GPR[rt]);
}

:function:::void:do_daui:int rt, int rs, unsigned16 immediate
{
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = GPR[rs] + (EXTEND16 (immediate) << 16);
  TRACE_ALU_RESULT (GPR[rt]);
}

:function:::void:do_dahi:int rs, unsigned16 immediate
{
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rs] = GPR[rs] + (EXTEND16 (immediate) << 32);
  TRACE_ALU_RESULT (GPR[rs]);
}

:function:::void:do_dati:int rs, unsigned16 immediate
{
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rs] = GPR[rs] + (EXTEND16 (immediate) << 48);
  TRACE_ALU_RESULT (GPR[rs]);
}

:function:::void:do_addiupc:int rs, unsigned32 immediate
{
  TRACE_ALU_INPUT1 (immediate);
  GPR[rs] = loadstore_ea (SD_, CIA & ~3, EXTEND19 (immediate) << 2);
  TRACE_ALU_RESULT (GPR[rs]);
}

:function:::void:do_auipc:int rs, unsigned16 immediate
{
  TRACE_ALU_INPUT1 (immediate);
  GPR[rs] = loadstore_ea (SD_, CIA, EXTEND32 (immediate << 16));
  TRACE_ALU_RESULT (GPR[rs]);
}

:function:::void:do_aluipc:int rs, unsigned16 immediate
{
  TRACE_ALU_INPUT1 (immediate);
  GPR[rs] = ~0x0FFFF & loadstore_ea (SD_, CIA, EXTEND32 (immediate << 16));
  TRACE_ALU_RESULT (GPR[rs]);
}

:function:::void:do_lwpc:int rs, unsigned32 immediate
{
  address_word offset = EXTEND19 (immediate) << 2;
  TRACE_ALU_INPUT1 (offset);
  GPR[rs] = EXTEND32 (do_load (SD_, AccessLength_WORD, CIA & ~3, offset));
  TRACE_ALU_RESULT (GPR[rs]);
}

:function:::void:do_lwupc:int rs, unsigned32 immediate
{
  address_word offset = EXTEND19 (immediate) << 2;
  TRACE_ALU_INPUT1 (offset);
  GPR[rs] = do_load (SD_, AccessLength_WORD, CIA & ~3, offset);
  TRACE_ALU_RESULT (GPR[rs]);
}

:function:::void:do_ldpc:int rs, unsigned32 immediate
{
  address_word offset = EXTEND18 (immediate) << 3;
  TRACE_ALU_INPUT1 (offset);
  GPR[rs] = do_load (SD_, AccessLength_DOUBLEWORD, CIA & ~7, offset);
  TRACE_ALU_RESULT (GPR[rs]);
}

110010,26.OFFSET:POOL32X:32::BC
"bc <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = do_bc (SD_, EXTEND26 (OFFSET) << 2);
}

111010,26.OFFSET:POOL32X:32::BALC
"balc <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = do_balc (SD_, EXTEND26 (OFFSET) << 2);
}

110110,5.RS!0,21.OFFSET:POOL32X:32::BEQZC
"beqzc r<RS>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = do_beqzc (SD_, RS, EXTEND21 (OFFSET) << 2, NIA);
}

110110,00000,5.RT,16.OFFSET:POOL32X:32::JIC
"jic r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = do_jic (SD_, RT, OFFSET);
}

111110,5.RS!0,21.OFFSET:POOL32X:32::BNEZC
"bnezc r<RS>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = do_bnezc (SD_, RS, EXTEND21 (OFFSET) << 2, NIA);
}

111110,00000,5.RT,16.OFFSET:POOL32X:32::JIALC
"jialc r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = do_jialc (SD_, RT, OFFSET);
}

010110,5.RS,5.RT,16.OFFSET:POOL32X:32::B1xxC
"blezc r<RT>, <OFFSET>": RS==0&&RT!=0
"bgezc r<RT>, <OFFSET>":RS!=0&&RS==RT
"bgec r<RS>, r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = do_b1xxc (SD_, RT, RS, EXTEND16 (OFFSET) << 2, NIA);
}

010111,5.RS,5.RT,16.OFFSET:POOL32X:32::B2xxC
"bgtzc r<RT>, <OFFSET>":RS==0&&RT!=0
"bltzc r<RT>, <OFFSET>":RS!=0&&RS==RT
"bltc r<RS>, r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = do_b2xxc (SD_, RT, RS, EXTEND16 (OFFSET) << 2, NIA);
}

000110,5.RS,5.RT!0,16.OFFSET:POOL32X:32::B3xxC
"blezalc r<RT>, <OFFSET>":RS==0
"bgezalc r<RT>, <OFFSET>":RS!=0&&RS==RT
"bgeuc r<RS>, r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = do_b3xxc (SD_, RT, RS, EXTEND16 (OFFSET) << 2, NIA);
}

000111,5.RS,5.RT!0,16.OFFSET:POOL32X:32::B4xxC
"bgtzalc r<RT>, <OFFSET>":RS==0
"bltzalc r<RT>, <OFFSET>":RS!=0&&RS==RT
"bltuc r<RS>, r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = do_b4xxc (SD_, RT, RS, EXTEND16 (OFFSET) << 2, NIA);
}

001000,5.RS,5.RT,16.OFFSET:POOL32X:32::BxxxC
"bovc r<RS>, r<RT>, <OFFSET>":RS>=RT
"beqzalc r<RT>, <OFFSET>":RS==0&&RT>RS
"beqc r<RS>, r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = do_bxxxc (SD_, RT, RS, EXTEND16 (OFFSET) << 2, NIA);
}

011000,5.RS,5.RT,16.OFFSET:POOL32X:32::BNxxxC
"bnvc r<RS>, r<RT>, <OFFSET>":RS>=RT
"bnezalc r<RT>, <OFFSET>":RS==0&&RT>RS
"bnec r<RS>, r<RT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  NIA = do_bnxxxc (SD_, RT, RS, EXTEND16 (OFFSET) << 2, NIA);
}

:%s::::R6COND:int r6cond
{
  switch (r6cond)
    {
    case FP_R6CMP_SAF:
      return "SAF";
    case FP_R6CMP_SUN:
      return "SUN";
    case FP_R6CMP_SOR:
      return "SOR";
    case FP_R6CMP_SEQ:
      return "SEQ";
    case FP_R6CMP_SUNE:
      return "SUNE";
    case FP_R6CMP_SUEQ:
      return "SUEQ";
    case FP_R6CMP_SNE:
      return "SNE";
    case FP_R6CMP_SLT:
      return "SLT";
    case FP_R6CMP_SULT:
      return "SULT";
    case FP_R6CMP_SLE:
      return "SLE";
    case FP_R6CMP_SULE:
      return "SULE";
    case FP_R6CMP_AF:
      return "AF";
    case FP_R6CMP_UN:
      return "UN";
    case FP_R6CMP_OR:
      return "OR";
    case FP_R6CMP_EQ:
      return "EQ";
    case FP_R6CMP_UNE:
      return "UNE";
    case FP_R6CMP_UEQ:
      return "UEQ";
    case FP_R6CMP_NE:
      return "NE";
    case FP_R6CMP_LT:
      return "LT";
    case FP_R6CMP_ULT:
      return "ULT";
    case FP_R6CMP_LE:
      return "LE";
    case FP_R6CMP_ULE:
      return "ULE";
    default:
      abort ();
    }
}

010001,1010,1.FMT,5.FT,5.FS,5.FD,0,5.R6COND:POOL32X:32,f::CMP.cond.fmt
"cmp.%s<R6COND>.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  do_cmp (SD_, FD, FS, FT, FMT, R6COND);
}

010001,01001,5.FT,16.OFFSET:POOL32X:32,f::BC1EQZ
"bc1eqz f<FT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  check_fpu (SD_);
  TRACE_ALU_INPUT1 (FGR[FT]);
  if ((FGR[FT] & 0x01) == 0)
    DELAY_SLOT (NIA + offset);
}

010001,01101,5.FT,16.OFFSET:POOL32X:32,f::BC1NEZ
"bc1nez f<FT>, <OFFSET>"
*mips32r6:
*mips64r6:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  check_fpu (SD_);
  TRACE_ALU_INPUT1 (FGR[FT]);
  if ((FGR[FT] & 0x01) != 0)
    DELAY_SLOT (NIA + offset);
}
010001,1000,1.FMT,5.FT,5.FS,5.FD,011000:POOLX:32,f::MADDF.fmt
"maddf.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  do_maddf (SD_, FD, FS, FT, FMT, instruction_0);
}

010001,1000,1.FMT,5.FT,5.FS,5.FD,011001:POOLX:32,f::MSUBF.fmt
"msubf.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  do_msubf (SD_, FD, FS, FT, FMT, instruction_0);
}

000000,5.RS,5.RT,5.RD,000,2.IMM,000101:SPECIAL:32::LSA
"lsa r<RD>, r<RS>, r<RT>, <IMM + 1>"
*mips32r6:
*mips64r6:
{
  do_lsa (SD_, RD, RS, RT, IMM);
}

000000,5.RS,5.RT,5.RD,000,2.IMM,010101:SPECIAL:64::DLSA
"dlsa r<RD>, r<RS>, r<RT>, <IMM + 1>"
*mips64r6:
{
  do_dlsa (SD_, RD, RS, RT, IMM);
}

001111,5.RS!0,5.RT,16.IMMEDIATE:POOL32X:32::AUI
"aui r<RS>, r<RT>, <IMMEDIATE>"
*mips32r6:
*mips64r6:
{
  do_aui (SD_, RT, RS, IMMEDIATE);
}

011101,5.RS!0,5.RT,16.IMMEDIATE:POOL32X:64::DAUI
"daui r<RS>, r<RT>, <IMMEDIATE>"
*mips64r6:
{
  do_daui (SD_, RT, RS, IMMEDIATE);
}

000001,5.RS,00110,16.IMMEDIATE:POOL32X:64::DAHI
"dahi r<RS>, <IMMEDIATE>"
*mips64r6:
{
  do_dahi (SD_, RS, IMMEDIATE);
}

000001,5.RS,11110,16.IMMEDIATE:POOL32X:64::DATI
"dati r<RS>, <IMMEDIATE>"
*mips64r6:
{
  do_dati (SD_, RS, IMMEDIATE);
}

011111,5.RS,5.RT,5.RD,010,2.IMMEDIATE,100000:POOL32X:32::ALIGN
"align r<RD>, r<RS>, r<RT>, <IMMEDIATE>"
*mips32r6:
*mips64r6:
{
  do_align (SD_, RD, RS, RT, IMMEDIATE);
}

011111,5.RS,5.RT,5.RD,01,3.IMMEDIATE,100100:POOL32X:64::DALIGN
"dalign r<RD>, r<RS>, r<RT>, <IMMEDIATE>"
*mips64r6:
{
  do_dalign (SD_, RD, RS, RT, IMMEDIATE);
}

011111,00000,5.RT,5.RD,00000,100000:POOL32X:32::BITSWAP
"bitswap r<RD>, r<RT>"
*mips32r6:
*mips64r6:
{
  do_bitswap (SD_, RD, RT);
}

011111,00000,5.RT,5.RD,00000,100100:POOL32X:64::DBITSWAP
"dbitswap r<RD>, r<RT>"
*mips64r6:
{
  do_dbitswap (SD_, RD, RT);
}

111011,5.RS,00,19.IMMEDIATE:POOL32X:32::ADDIUPC
"addiupc r<RS>, <IMMEDIATE>"
*mips32r6:
*mips64r6:
{
  do_addiupc (SD_, RS, IMMEDIATE);
}

111011,5.RS,11110,16.IMMEDIATE:POOL32X:32::AUIPC
"auipc r<RS>, <IMMEDIATE>"
*mips32r6:
*mips64r6:
{
  do_auipc(SD_, RS, IMMEDIATE);
}

111011,5.RS,11111,16.IMMEDIATE:POOL32X:32::ALUIPC
"aluipc r<RS>, <IMMEDIATE>"
*mips32r6:
*mips64r6:
{
  do_aluipc (SD_, RS, IMMEDIATE);
}

111011,5.RS,01,19.IMMEDIATE:POOL32X:32::LWPC
"lwpc r<RS>, <IMMEDIATE>"
*mips32r6:
*mips64r6:
{
  do_lwpc (SD_, RS, IMMEDIATE);
}

111011,5.RS,10,19.IMMEDIATE:POOL32X:64::LWUPC
"lwupc r<RS>, <IMMEDIATE>"
*mips64r6:
{
  do_lwupc (SD_, RS, IMMEDIATE);
}

111011,5.RS,110,18.IMMEDIATE:POOL32X:64::LDPC
"ldpc r<RS>, <IMMEDIATE>"
*mips64r6:
{
  do_ldpc (SD_, RS, IMMEDIATE);
}
010001,1000,1.FMT,00000,5.FS,5.FD,011010::32,64,f::RINT.fmt
"rint.%s<FMT> f<FD>, f<FS>"
*mips32r6:
*mips64r6:
{
  do_rint (SD_, FD, FS, FMT, instruction_0);
}

010001,1000,1.FMT,00000,5.FS,5.FD,011011::32,64,f::CLASS.fmt
"class.%s<FMT> f<FD>, f<FS>"
*mips32r6:
*mips64r6:
{
  do_class (SD_, FD, FS, FMT, instruction_0);
}

010001,1000,1.FMT,5.FT,5.FS,5.FD,011100::32,64,f::MIN.fmt
"min.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  do_min (SD_, FD, FS, FT, FMT, instruction_0);
}

010001,1000,1.FMT,5.FT,5.FS,5.FD,011110::32,64,f::MAX.fmt
"max.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  do_max (SD_, FD, FS, FT, FMT, instruction_0);
}

010001,1000,1.FMT,5.FT,5.FS,5.FD,011101::32,64,f::MINA.fmt
"mina.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  do_mina (SD_, FD, FS, FT, FMT, instruction_0);
}

010001,1000,1.FMT,5.FT,5.FS,5.FD,011111::32,64,f::MAXA.fmt
"maxa.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  do_maxa (SD_, FD, FS, FT, FMT, instruction_0);
}

000000,5.RS,5.RT,5.RD,00010,011000:POOL32X:32::MUL
"mul r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  do_mul (SD_, RD, RS, RT);
}

000000,5.RS,5.RT,5.RD,00011,011000:POOL32X:32::MUH
"muh r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  do_muh (SD_, RD, RS, RT);
}

000000,5.RS,5.RT,5.RD,00010,011001:POOL32X:32::MULU
"mulu r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  do_mulu (SD_, RD, RS, RT);
}

000000,5.RS,5.RT,5.RD,00011,011001:POOL32X:32::MUHU
"muhu r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  do_muhu (SD_, RD, RS, RT);
}

000000,5.RS,5.RT,5.RD,00010,011010:POOL32X:32::DIV
"div r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  do_div (SD_, RD, RS, RT);
}

000000,5.RS,5.RT,5.RD,00011,011010:POOL32X:32::MOD
"mod r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  do_mod (SD_, RD, RS, RT);
}

000000,5.RS,5.RT,5.RD,00010,011011:POOL32X:32::DIVU
"divu r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  do_divu (SD_, RD, RS, RT);
}

000000,5.RS,5.RT,5.RD,00011,011011:POOL32X:32::MODU
"modu r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  do_modu (SD_, RD, RS, RT);
}

000000,5.RS,5.RT,5.RD,00010,011100:POOL32X:64::DMUL
"dmul r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  do_dmul (SD_, RD, RS, RT, instruction_0);
}

000000,5.RS,5.RT,5.RD,00011,011100:POOL32X:64::DMUH
"dmuh r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  do_dmuh (SD_, RD, RS, RT, instruction_0);
}

000000,5.RS,5.RT,5.RD,00010,011101:POOL32X:64::DMULU
"dmulu r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  do_dmulu (SD_, RD, RS, RT, instruction_0);
}

000000,5.RS,5.RT,5.RD,00011,011101:POOL32X:64::DMUHU
"dmuhu r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  do_dmuhu (SD_, RD, RS, RT, instruction_0);
}

000000,5.RS,5.RT,5.RD,00010,011110:POOL32X:64::DDIV
"ddiv r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  do_ddiv (SD_, RD, RS, RT, instruction_0);
}

000000,5.RS,5.RT,5.RD,00011,011110:POOL32X:64::DMOD
"dmod r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  do_dmod (SD_, RD, RS, RT, instruction_0);
}

000000,5.RS,5.RT,5.RD,00010,011111:POOL32X:64::DDIVU
"ddivu r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  do_ddivu (SD_, RD, RS, RT, instruction_0);
}

000000,5.RS,5.RT,5.RD,00011,011111:POOL32X:64::DMODU
"dmodu r<RD>, r<RS>, r<RT>"
*mips64r6:
{
  do_dmodu (SD_, RD, RS, RT, instruction_0);
}

011111,5.BASE,5.RT,9.OFFSET,0,110110:SPECIAL3:32::LL
"ll r<RT>, <OFFSET>(r<BASE>)"
*mips32r6:
*mips64r6:
{
  do_ll (SD_, RT, OFFSET, BASE);
}

011111,5.BASE,5.RT,5.RD,0000,1,110110:SPECIAL3:32::LLWP
"llwp r<RT>, r<RD>, (r<BASE>)"
*mips32r6:
*mips64r6:
{
  int first, second;
  int offset;

  if (RT == BASE)
  {
    first = RD;
    second = RT;
    offset = BigEndianCPU ? 0 : 4;
  }
  else
  {
    first = RT;
    second = RD;
    offset = BigEndianCPU ? 4 : 0;
  }

  do_ll (SD_, first, offset, BASE);
  do_ll (SD_, second, offset ^ 4, BASE);
}


011111,5.BASE,5.RT,9.OFFSET,0,100110:SPECIAL3:32::SC
"sc r<RT>, <OFFSET>(r<BASE>)"
*mips32r6:
*mips64r6:
{
  do_sc (SD_, RT, OFFSET, BASE, instruction_0, 1);
}

011111,5.BASE,5.RT,9.OFFSET,0,110111:SPECIAL3:64::LLD
"lld r<RT>, <OFFSET>(r<BASE>)"
*mips64r6:
{
  check_u64 (SD_, instruction_0);
  do_lld (SD_, RT, OFFSET, BASE);
}


011111,5.BASE,5.RT,5.RD,0000,1,100110:SPECIAL3:32::SCWP
"scwp r<RT>, r<RD>, (r<BASE>)"
*mips32r6:
*mips64r6:
{
  int offset = BigEndianCPU ? 0 : 4;

  do_sc (SD_, RD, offset, BASE, instruction_0, 0);
  do_sc (SD_, RT, offset ^ 4, BASE, instruction_0, 1);
}

011111,5.BASE,5.RT,5.RD,0000,1,110111:SPECIAL3:64::LLDP
"lldp r<RT>, r<RD>, (r<BASE>)"
*mips64r6:
{
  int first, second;
  int offset;

  check_u64 (SD_, instruction_0);

  if (RT == BASE)
  {
    first = RD;
    second = RT;
    offset = BigEndianCPU ? 0 : 8;
  }
  else
  {
    first = RT;
    second = RD;
    offset = BigEndianCPU ? 8 : 0;
  }

  do_lld (SD_, first, offset, BASE);
  do_lld (SD_, second, offset ^ 8, BASE);
}

011111,5.BASE,5.RT,9.OFFSET,0,100111:SPECIAL3:64::SCD
"scd r<RT>, <OFFSET>(r<BASE>)"
*mips64r6:
{
  check_u64 (SD_, instruction_0);
  do_scd (SD_, RT, OFFSET, BASE, 1);
}

011111,5.BASE,5.RT,5.RD,0000,1,100111:SPECIAL3:64::SCDP
"scdp r<RT>, r<RD>, (r<BASE>)"
*mips64r6:
{
  int offset = BigEndianCPU ? 0 : 8;
  check_u64 (SD_, instruction_0);

  do_scd (SD_, RD, offset, BASE, 0);
  do_scd (SD_, RT, offset ^ 8, BASE, 1);
}

011111,5.BASE,5.HINT,9.OFFSET,0,110101:SPECIAL3:32::PREF
"pref <HINT>, <OFFSET>(r<BASE>)"
*mips32r6:
*mips64r6:
{
  do_pref (SD_, HINT, OFFSET, BASE);
}

011111,5.BASE,5.HINT,9.OFFSET,0,100101:SPECIAL3:32::CACHE
"cache <HINT>, <OFFSET>(r<BASE>)"
*mips32r6:
*mips64r6:
{
  do_cache (SD_, HINT, BASE, OFFSET, instruction_0);
}


000000,5.RS,00000,5.RD,00001,010000:POOL32X:32::CLZ
"clz r<RD>, r<RS>"
*mips32r6:
*mips64r6:
{
  do_clz (SD_, RD, RS);
}

000000,5.RS,00000,5.RD,00001,010001:POOL32X:32::CLO
"clo r<RD>, r<RS>"
*mips32r6:
*mips64r6:
{
  do_clo (SD_, RD, RS);
}

000000,5.RS,00000,5.RD,00001,010010:POOL32X:64::DCLZ
"dclz r<RD>, r<RS>"
*mips64r6:
{
  check_u64 (SD_, instruction_0);
  do_dclz (SD_, RD, RS);
}

000000,5.RS,00000,5.RD,00001,010011:POOL32X:64::DCLO
"dclo r<RD>, r<RS>"
*mips64r6:
{
  check_u64 (SD_, instruction_0);
  do_dclo (SD_, RD, RS);
}
010001,1000,1.FMT,5.FT,5.FS,5.FD,010000:POOL32X:32,f::SEL.fmt
"sel.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  do_self (SD_, FD, FS, FT, FMT, instruction_0);
}

010001,1000,1.FMT,5.FT,5.FS,5.FD,010100:POOL32X:32,f::SELEQZ.fmt
"seleqz.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  do_seleqzf (SD_, FD, FS, FT, FMT, instruction_0);
}

010001,1000,1.FMT,5.FT,5.FS,5.FD,010111:POOL32X:32,f::SELNEZ.fmt
"selnez.%s<FMT> f<FD>, f<FS>, f<FT>"
*mips32r6:
*mips64r6:
{
  do_selnezf (SD_, FD, FS, FT, FMT, instruction_0);
}

000000,5.RS,5.RT,5.RD,00000,110101:POOL32X:32::SELEQZ
"seleqz r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  do_seleqz (SD_, RD, RS, RT);
}

000000,5.RS,5.RT,5.RD,00000,110111:POOL32X:32::SELNEZ
"selnez r<RD>, r<RS>, r<RT>"
*mips32r6:
*mips64r6:
{
  do_selnez (SD_, RD, RS, RT);
}
